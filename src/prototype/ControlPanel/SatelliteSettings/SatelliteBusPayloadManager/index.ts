import { calculateBaseAxes } from './_util/base-axes-calculator.js';
import { calculateAntennaOrientation } from './_util/antenna-orientation-calculator.js';
import { createBusEntity, createAntennaEntity, calculateBusOrientation, calculateAntennaOrientationForUI } from './_ui/entity-creator.js';
import { createAxisEntities } from './_ui/axis-creator.js';
import { createDirectionArrows } from './_ui/direction-arrows-creator.js';

/**
 * SatelliteBusPayloadManager - BUS와 Payload(안테나) 엔티티 관리 클래스
 */
export class SatelliteBusPayloadManager {
  private viewer: any;
  private busEntity: any;
  private antennaEntity: any;
  private position: any;
  private currentCartesian: any;
  private axisEntities: {
    xAxis: any;
    yAxis: any;
    zAxis: any;
    xLabel: any;
    yLabel: any;
    zLabel: any;
  } | null;
  private axisLength: number;
  private axisVisible: boolean;
  private busDimensions: { length: number; width: number; height: number } | null;
  private antennaParams: {
    height: number;
    width: number;
    depth: number;
    rollAngle: number;
    pitchAngle: number;
    yawAngle: number;
    initialElevationAngle: number;
    initialAzimuthAngle: number;
  } | null;
  private antennaGap: number; // 버스와 안테나 사이 간격 (미터)
  private directionArrows: {
    positive: any;
    negative: any;
    positiveLabel: any;
    negativeLabel: any;
  } | null;

  constructor(viewer: any) {
    this.viewer = viewer;
    this.busEntity = null;
    this.antennaEntity = null;
    this.position = null;
    this.currentCartesian = null;
    this.axisEntities = null;
    this.axisLength = 5; // 기본값: 1km
    this.axisVisible = true;
    this.busDimensions = null;
    this.antennaParams = null;
    this.antennaGap = 0.1; // 기본값: 100mm (미터 단위)
    this.directionArrows = null;
  }

  /**
   * BUS와 안테나 엔티티 생성
   */
  createSatellite(
    name: string,
    position: { longitude: number; latitude: number; altitude: number },
    busDimensions: { length: number; width: number; height: number },
    antennaParams: {
      height: number;
      width: number;
      depth: number;
      rollAngle: number;
      pitchAngle: number;
      yawAngle: number;
      initialElevationAngle: number;
      initialAzimuthAngle: number;
    },
    antennaGap?: number // 버스와 안테나 사이 간격 (미터)
  ): void {
    if (!this.viewer) {
      console.error('[SatelliteBusPayloadManager] Viewer가 없습니다.');
      return;
    }

    // 기존 엔티티 제거
    this.removeSatellite();

    const initialCartesian = Cesium.Cartesian3.fromDegrees(
      position.longitude,
      position.latitude,
      position.altitude
    );

    this.position = new Cesium.ConstantPositionProperty(initialCartesian);
    this.currentCartesian = initialCartesian.clone();

    // 파라미터 저장
    this.busDimensions = busDimensions;
    this.antennaParams = antennaParams;
    this.antennaGap = antennaGap !== undefined ? antennaGap : 0.1; // 기본값: 100mm

    // BUS 기본 방향 계산
    const busAxes = calculateBaseAxes(this.currentCartesian);
    if (!busAxes) {
      console.error('[SatelliteBusPayloadManager] BUS 축 계산 실패');
      return;
    }

    // BUS 방향 쿼터니언 계산 (기본 방향 - 동쪽을 향하도록)
    const busOrientation = calculateBusOrientation(initialCartesian);

    // BUS 엔티티 생성
    try {
      this.busEntity = createBusEntity(
        this.viewer,
        name,
        this.position,
        busOrientation,
        busDimensions
      );
    } catch (error) {
      console.error('[SatelliteBusPayloadManager] BUS 엔티티 생성 오류:', error);
      return;
    }

    // 안테나 위치 계산 (BUS의 Y축 방향)
    try {
      // BUS의 Y축 방향으로 안테나 위치 설정 (BUS 크기의 절반 + 안테나 깊이의 절반 + 간격)
      const antennaOffset = Cesium.Cartesian3.multiplyByScalar(
        busAxes.yAxis,
        busDimensions.width / 2 + antennaParams.depth / 2 + this.antennaGap,
        new Cesium.Cartesian3()
      );
      const antennaPosition = Cesium.Cartesian3.add(
        this.currentCartesian,
        antennaOffset,
        new Cesium.Cartesian3()
      );
      const antennaPositionProperty = new Cesium.ConstantPositionProperty(antennaPosition);

      // 안테나 방향 계산
      const antennaOrientation = calculateAntennaOrientationForUI(
        this.currentCartesian,
        antennaParams.rollAngle,
        antennaParams.pitchAngle,
        antennaParams.yawAngle,
        antennaParams.initialElevationAngle,
        antennaParams.initialAzimuthAngle
      );

      if (!antennaOrientation) {
        console.error('[SatelliteBusPayloadManager] 안테나 방향 계산 실패');
        return;
      }

      // 안테나 엔티티 생성
      this.antennaEntity = createAntennaEntity(
        this.viewer,
        name,
        antennaPositionProperty,
        antennaOrientation,
        {
          depth: antennaParams.depth,
          width: antennaParams.width,
          height: antennaParams.height
        }
      );
    } catch (error) {
      console.error('[SatelliteBusPayloadManager] 안테나 엔티티 생성 오류:', error);
    }

    // XYZ 축 생성
    try {
      this.createAxisLines();
    } catch (error) {
      console.error('[SatelliteBusPayloadManager] XYZ 축 생성 오류:', error);
    }
  }


  /**
   * XYZ 축 방향선 생성
   */
  private createAxisLines(): void {
    if (!this.viewer || !this.position || !this.currentCartesian) return;

    this.axisEntities = createAxisEntities(
      this.viewer,
      this.currentCartesian,
      this.axisLength,
      this.axisVisible
    );
  }


  /**
   * 위성 위치 업데이트
   */
  updatePosition(position: { longitude: number; latitude: number; altitude: number }): void {
    if (!this.position || !this.currentCartesian) {
      console.warn('[SatelliteBusPayloadManager] 위치를 업데이트할 엔티티가 없습니다.');
      return;
    }

    if (!this.busDimensions || !this.antennaParams) {
      console.warn('[SatelliteBusPayloadManager] BUS 또는 안테나 파라미터가 없습니다.');
      return;
    }

    try {
      const newCartesian = Cesium.Cartesian3.fromDegrees(
        position.longitude,
        position.latitude,
        position.altitude
      );

      this.currentCartesian = newCartesian.clone();
      this.position.setValue(newCartesian);

      // BUS 방향 재계산
      const busAxes = calculateBaseAxes(this.currentCartesian);
      if (busAxes) {
        const busOrientation = Cesium.Transforms.headingPitchRollQuaternion(
          newCartesian,
          new Cesium.HeadingPitchRoll(0, 0, 0)
        );

        if (this.busEntity) {
          this.busEntity.orientation = new Cesium.ConstantProperty(busOrientation);
        }

        // 안테나 위치 재계산
        if (this.antennaEntity && this.antennaParams) {
          const antennaOffset = Cesium.Cartesian3.multiplyByScalar(
            busAxes.yAxis,
            this.busDimensions.width / 2 + this.antennaParams.depth / 2 + this.antennaGap,
            new Cesium.Cartesian3()
          );
          const antennaPosition = Cesium.Cartesian3.add(
            this.currentCartesian,
            antennaOffset,
            new Cesium.Cartesian3()
          );
          const antennaPositionProperty = new Cesium.ConstantPositionProperty(antennaPosition);
          this.antennaEntity.position = antennaPositionProperty;

          // 안테나 방향도 재계산
          const antennaOrientation = calculateAntennaOrientation(
            busAxes,
            this.antennaParams.rollAngle,
            this.antennaParams.pitchAngle,
            this.antennaParams.yawAngle,
            this.antennaParams.initialElevationAngle,
            this.antennaParams.initialAzimuthAngle
          );
          this.antennaEntity.orientation = new Cesium.ConstantProperty(antennaOrientation);
        }
      }

      // XYZ 축 재생성 (currentCartesian 업데이트 반영)
      if (this.axisEntities) {
        // 기존 축 제거
        if (this.axisEntities.xAxis) this.viewer.entities.remove(this.axisEntities.xAxis);
        if (this.axisEntities.yAxis) this.viewer.entities.remove(this.axisEntities.yAxis);
        if (this.axisEntities.zAxis) this.viewer.entities.remove(this.axisEntities.zAxis);
        if (this.axisEntities.xLabel) this.viewer.entities.remove(this.axisEntities.xLabel);
        if (this.axisEntities.yLabel) this.viewer.entities.remove(this.axisEntities.yLabel);
        if (this.axisEntities.zLabel) this.viewer.entities.remove(this.axisEntities.zLabel);
        
        // 새로운 위치로 축 재생성
        this.createAxisLines();
      }

      console.log('[SatelliteBusPayloadManager] 위치 업데이트 완료:', position);
    } catch (error) {
      console.error('[SatelliteBusPayloadManager] 위치 업데이트 오류:', error);
    }
  }

  /**
   * BUS 크기 업데이트
   */
  updateBusDimensions(dimensions: { length: number; width: number; height: number }): void {
    if (!this.busEntity) {
      return;
    }

    try {
      this.busDimensions = dimensions;

      if (this.busEntity.box) {
        this.busEntity.box.dimensions = new Cesium.Cartesian3(
          dimensions.length,
          dimensions.width,
          dimensions.height
        );
      }

      // 안테나 위치도 재계산 (BUS 크기가 변경되면 안테나 위치도 변경됨)
      if (this.antennaEntity && this.antennaParams && this.currentCartesian) {
        const busAxes = calculateBaseAxes(this.currentCartesian);
        if (busAxes) {
          const antennaOffset = Cesium.Cartesian3.multiplyByScalar(
            busAxes.yAxis,
            dimensions.width / 2 + this.antennaParams.depth / 2 + this.antennaGap,
            new Cesium.Cartesian3()
          );
          const antennaPosition = Cesium.Cartesian3.add(
            this.currentCartesian,
            antennaOffset,
            new Cesium.Cartesian3()
          );
          const antennaPositionProperty = new Cesium.ConstantPositionProperty(antennaPosition);
          this.antennaEntity.position = antennaPositionProperty;
        }
      }

      console.log('[SatelliteBusPayloadManager] BUS 크기 업데이트 완료:', dimensions);
    } catch (error) {
      console.error('[SatelliteBusPayloadManager] BUS 크기 업데이트 오류:', error);
    }
  }

  /**
   * 안테나 크기 업데이트
   */
  updateAntennaDimensions(dimensions: { height: number; width: number; depth: number }): void {
    if (!this.antennaEntity || !this.antennaParams) {
      return;
    }

    try {
      this.antennaParams.height = dimensions.height;
      this.antennaParams.width = dimensions.width;
      this.antennaParams.depth = dimensions.depth;

      if (this.antennaEntity.box) {
        this.antennaEntity.box.dimensions = new Cesium.Cartesian3(
          dimensions.depth,
          dimensions.width,
          dimensions.height
        );
      }

      // 안테나 위치도 재계산 (안테나 depth가 변경되면 위치도 변경됨)
      if (this.busDimensions && this.currentCartesian) {
        const busAxes = calculateBaseAxes(this.currentCartesian);
        if (busAxes) {
          const antennaOffset = Cesium.Cartesian3.multiplyByScalar(
            busAxes.yAxis,
            this.busDimensions.width / 2 + dimensions.depth / 2 + this.antennaGap,
            new Cesium.Cartesian3()
          );
          const antennaPosition = Cesium.Cartesian3.add(
            this.currentCartesian,
            antennaOffset,
            new Cesium.Cartesian3()
          );
          const antennaPositionProperty = new Cesium.ConstantPositionProperty(antennaPosition);
          this.antennaEntity.position = antennaPositionProperty;
        }
      }

      console.log('[SatelliteBusPayloadManager] 안테나 크기 업데이트 완료:', dimensions);
    } catch (error) {
      console.error('[SatelliteBusPayloadManager] 안테나 크기 업데이트 오류:', error);
    }
  }

  /**
   * 버스와 안테나 사이 간격 업데이트
   */
  updateAntennaGap(gap: number): void {
    if (!this.antennaEntity || !this.busDimensions || !this.antennaParams || !this.currentCartesian) {
      return;
    }

    try {
      this.antennaGap = gap;

      // 안테나 위치 재계산
      const busAxes = calculateBaseAxes(this.currentCartesian);
      if (busAxes) {
        const antennaOffset = Cesium.Cartesian3.multiplyByScalar(
          busAxes.yAxis,
          this.busDimensions.width / 2 + this.antennaParams.depth / 2 + this.antennaGap,
          new Cesium.Cartesian3()
        );
        const antennaPosition = Cesium.Cartesian3.add(
          this.currentCartesian,
          antennaOffset,
          new Cesium.Cartesian3()
        );
        const antennaPositionProperty = new Cesium.ConstantPositionProperty(antennaPosition);
        this.antennaEntity.position = antennaPositionProperty;
      }

      console.log('[SatelliteBusPayloadManager] 안테나 간격 업데이트 완료:', gap);
    } catch (error) {
      console.error('[SatelliteBusPayloadManager] 안테나 간격 업데이트 오류:', error);
    }
  }

  /**
   * 안테나 방향 업데이트
   */
  updateAntennaOrientation(orientation: {
    rollAngle: number;
    pitchAngle: number;
    yawAngle: number;
    initialElevationAngle: number;
    initialAzimuthAngle: number;
  }): void {
    if (!this.antennaEntity || !this.antennaParams || !this.currentCartesian) {
      return;
    }

    try {
      this.antennaParams.rollAngle = orientation.rollAngle;
      this.antennaParams.pitchAngle = orientation.pitchAngle;
      this.antennaParams.yawAngle = orientation.yawAngle;
      this.antennaParams.initialElevationAngle = orientation.initialElevationAngle;
      this.antennaParams.initialAzimuthAngle = orientation.initialAzimuthAngle;

      const busAxes = calculateBaseAxes(this.currentCartesian);
      if (busAxes) {
        const antennaOrientation = calculateAntennaOrientation(
          busAxes,
          orientation.rollAngle,
          orientation.pitchAngle,
          orientation.yawAngle,
          orientation.initialElevationAngle,
          orientation.initialAzimuthAngle
        );
        this.antennaEntity.orientation = new Cesium.ConstantProperty(antennaOrientation);
      }

      console.log('[SatelliteBusPayloadManager] 안테나 방향 업데이트 완료:', orientation);
    } catch (error) {
      console.error('[SatelliteBusPayloadManager] 안테나 방향 업데이트 오류:', error);
    }
  }

  /**
   * 모든 파라미터 업데이트 (편의 메서드)
   */
  updateAll(params: {
    position?: { longitude: number; latitude: number; altitude: number };
    busDimensions?: { length: number; width: number; height: number };
    antennaDimensions?: { height: number; width: number; depth: number };
    antennaOrientation?: {
      rollAngle: number;
      pitchAngle: number;
      yawAngle: number;
      initialElevationAngle: number;
      initialAzimuthAngle: number;
    };
    antennaGap?: number;
  }): void {
    if (params.position) {
      this.updatePosition(params.position);
    }
    if (params.busDimensions) {
      this.updateBusDimensions(params.busDimensions);
    }
    if (params.antennaDimensions) {
      this.updateAntennaDimensions(params.antennaDimensions);
    }
    if (params.antennaOrientation) {
      this.updateAntennaOrientation(params.antennaOrientation);
    }
    if (params.antennaGap !== undefined) {
      this.updateAntennaGap(params.antennaGap);
    }
  }

  /**
   * 위성 엔티티 제거
   */
  removeSatellite(): void {
    if (this.busEntity) {
      this.viewer.entities.remove(this.busEntity);
      this.busEntity = null;
    }
    if (this.antennaEntity) {
      this.viewer.entities.remove(this.antennaEntity);
      this.antennaEntity = null;
    }
    if (this.axisEntities) {
      if (this.axisEntities.xAxis) this.viewer.entities.remove(this.axisEntities.xAxis);
      if (this.axisEntities.yAxis) this.viewer.entities.remove(this.axisEntities.yAxis);
      if (this.axisEntities.zAxis) this.viewer.entities.remove(this.axisEntities.zAxis);
      if (this.axisEntities.xLabel) this.viewer.entities.remove(this.axisEntities.xLabel);
      if (this.axisEntities.yLabel) this.viewer.entities.remove(this.axisEntities.yLabel);
      if (this.axisEntities.zLabel) this.viewer.entities.remove(this.axisEntities.zLabel);
      this.axisEntities = null;
    }
    this.position = null;
    this.currentCartesian = null;
    this.busDimensions = null;
    this.antennaParams = null;
    
    // 방향 화살표 제거
    this.removeDirectionArrows();
  }

  /**
   * XYZ 축 표시/숨김 설정
   */
  setAxisVisible(visible: boolean): void {
    this.axisVisible = visible;
    if (this.axisEntities) {
      this.axisEntities.xAxis.polyline.show = visible;
      this.axisEntities.yAxis.polyline.show = visible;
      this.axisEntities.zAxis.polyline.show = visible;
      this.axisEntities.xLabel.label.show = visible;
      this.axisEntities.yLabel.label.show = visible;
      this.axisEntities.zLabel.label.show = visible;
    }
  }

  /**
   * 축 길이 설정
   */
  setAxisLength(length: number): void {
    this.axisLength = length;
  }

  /**
   * BUS 엔티티 반환
   */
  getBusEntity(): any {
    return this.busEntity;
  }

  /**
   * 안테나 엔티티 반환
   */
  getAntennaEntity(): any {
    return this.antennaEntity;
  }

  /**
   * 방향 화살표 표시
   * @param direction 방향 ('bus_length' | 'bus_width' | 'bus_height' | 'antenna_height' | 'antenna_width' | 'antenna_depth' | 'antenna_gap' | 'antenna_roll' | 'antenna_pitch' | 'antenna_yaw' | 'antenna_elevation' | 'antenna_azimuth')
   */
  showDirectionArrows(direction: string): void {
    // 기존 화살표 제거
    this.removeDirectionArrows();

    if (!this.viewer || !this.currentCartesian || !this.busEntity) {
      return;
    }

    const arrows = createDirectionArrows(
      this.viewer,
      this.currentCartesian,
      direction
    );

    if (arrows) {
      this.directionArrows = arrows;
    }
  }

  /**
   * 방향 화살표 제거
   */
  removeDirectionArrows(): void {
    if (this.directionArrows) {
      if (this.directionArrows.positive) this.viewer.entities.remove(this.directionArrows.positive);
      if (this.directionArrows.negative) this.viewer.entities.remove(this.directionArrows.negative);
      if (this.directionArrows.positiveLabel) this.viewer.entities.remove(this.directionArrows.positiveLabel);
      if (this.directionArrows.negativeLabel) this.viewer.entities.remove(this.directionArrows.negativeLabel);
      this.directionArrows = null;
    }
  }
}
